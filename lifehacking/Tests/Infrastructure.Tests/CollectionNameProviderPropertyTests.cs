using FsCheck;
using FsCheck.Xunit;
using Infrastructure.Data.Firestore;
using Xunit;

namespace Infrastructure.Tests;

/// <summary>
/// Property-based tests for collection name provider implementations.
/// Feature: firestore-test-infrastructure-improvements
/// </summary>
public sealed class CollectionNameProviderPropertyTests
{
    // Feature: firestore-test-infrastructure-improvements, Property 1: Collection Name Uniqueness and Format
    // For any two FirestoreTestBase instances created concurrently or sequentially, the collection names 
    // generated by their CollectionNameProviders should be distinct, and each collection name should follow 
    // the pattern {baseCollectionName}_{uniqueIdentifier} where the unique identifier is an 8-character 
    // alphanumeric string.
    // Validates: Requirements 1.1, 1.2, 1.3, 1.5, 9.1, 9.2

    /// <summary>
    /// Property: Multiple TestCollectionNameProvider instances should generate unique collection names.
    /// This property verifies that concurrent or sequential test instances will not interfere with each other.
    /// </summary>
    [Property(MaxTest = 100)]
    public void MultipleProviders_ShouldGenerateUniqueCollectionNames_WhenCreatedConcurrently(NonEmptyString baseCollectionName)
    {
        // Precondition: Skip whitespace-only strings
        var baseName = baseCollectionName.Get;
        if (string.IsNullOrWhiteSpace(baseName))
        {
            return;
        }

        // Arrange: Create multiple provider instances (simulating concurrent tests)
        var providers = Enumerable.Range(0, 10)
            .Select(_ => new TestCollectionNameProvider())
            .ToList();

        // Act: Get collection names from all providers
        var collectionNames = providers
            .Select(p => p.GetCollectionName(baseName))
            .ToList();

        // Assert: All collection names should be unique
        var uniqueNames = collectionNames.Distinct().Count();
        Assert.Equal(collectionNames.Count, uniqueNames);
    }

    /// <summary>
    /// Property: Collection names should follow the pattern {baseCollectionName}_{8-char-hex}.
    /// This property verifies the naming convention is consistently applied.
    /// </summary>
    [Property(MaxTest = 100)]
    public void CollectionNames_ShouldFollowNamingPattern_WhenGenerated(NonEmptyString baseCollectionName)
    {
        // Precondition: Skip whitespace-only strings
        var baseName = baseCollectionName.Get;
        if (string.IsNullOrWhiteSpace(baseName))
        {
            return;
        }

        // Arrange
        var provider = new TestCollectionNameProvider();

        // Act
        var collectionName = provider.GetCollectionName(baseName);

        // Assert: Should start with base name followed by underscore
        Assert.StartsWith($"{baseName}_", collectionName);

        // Assert: The suffix after the base name should be exactly 8 hexadecimal characters
        var suffix = collectionName.Substring(baseName.Length + 1); // +1 for underscore
        Assert.Equal(8, suffix.Length);
        Assert.True(suffix.All(c => (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')),
            $"Suffix '{suffix}' should contain only hexadecimal characters");
    }

    /// <summary>
    /// Property: Same provider instance should return consistent names for the same base collection name.
    /// This property verifies that a provider's unique identifier is stable across multiple calls.
    /// </summary>
    [Property(MaxTest = 100)]
    public void SameProvider_ShouldReturnConsistentNames_WhenCalledMultipleTimes(NonEmptyString baseCollectionName)
    {
        // Precondition: Skip whitespace-only strings
        var baseName = baseCollectionName.Get;
        if (string.IsNullOrWhiteSpace(baseName))
        {
            return;
        }

        // Arrange
        var provider = new TestCollectionNameProvider();

        // Act: Call multiple times
        var name1 = provider.GetCollectionName(baseName);
        var name2 = provider.GetCollectionName(baseName);
        var name3 = provider.GetCollectionName(baseName);

        // Assert: All names should be identical
        Assert.Equal(name1, name2);
        Assert.Equal(name2, name3);
    }

    /// <summary>
    /// Property: Same provider instance should use the same suffix for different base collection names.
    /// This property verifies that the unique identifier is per-provider-instance, not per-collection.
    /// </summary>
    [Property(MaxTest = 100)]
    public void SameProvider_ShouldUseSameSuffix_ForDifferentBaseNames(NonEmptyString baseName1, NonEmptyString baseName2)
    {
        // Precondition: Skip whitespace-only strings
        var name1 = baseName1.Get;
        var name2 = baseName2.Get;
        if (string.IsNullOrWhiteSpace(name1) || string.IsNullOrWhiteSpace(name2))
        {
            return;
        }

        // Skip if base names are the same (not interesting for this property)
        if (name1 == name2)
        {
            return;
        }

        // Arrange
        var provider = new TestCollectionNameProvider();

        // Act
        var collectionName1 = provider.GetCollectionName(name1);
        var collectionName2 = provider.GetCollectionName(name2);

        // Extract suffixes
        var suffix1 = collectionName1.Substring(name1.Length + 1);
        var suffix2 = collectionName2.Substring(name2.Length + 1);

        // Assert: Suffixes should be identical
        Assert.Equal(suffix1, suffix2);
    }

    /// <summary>
    /// Property: ProductionCollectionNameProvider should always return the base name unchanged.
    /// This property verifies that production provider does not apply any transformations.
    /// </summary>
    [Property(MaxTest = 100)]
    public void ProductionProvider_ShouldReturnBaseNameUnchanged_Always(NonEmptyString baseCollectionName)
    {
        // Precondition: Skip whitespace-only strings
        var baseName = baseCollectionName.Get;
        if (string.IsNullOrWhiteSpace(baseName))
        {
            return;
        }

        // Arrange
        var provider = new ProductionCollectionNameProvider();

        // Act
        var collectionName = provider.GetCollectionName(baseName);

        // Assert: Should be exactly the base name
        Assert.Equal(baseName, collectionName);
    }

    /// <summary>
    /// Property: Collection name providers should handle various valid base collection names.
    /// This property verifies robustness across different input patterns.
    /// </summary>
    [Property(MaxTest = 100)]
    public void Providers_ShouldHandleVariousValidNames_WithoutErrors(NonEmptyString baseCollectionName)
    {
        // Precondition: Skip whitespace-only strings
        var baseName = baseCollectionName.Get;
        if (string.IsNullOrWhiteSpace(baseName))
        {
            return;
        }

        // Arrange
        var testProvider = new TestCollectionNameProvider();
        var prodProvider = new ProductionCollectionNameProvider();

        // Act
        var testName = testProvider.GetCollectionName(baseName);
        var prodName = prodProvider.GetCollectionName(baseName);

        // Assert: Should not throw and should return non-empty strings
        Assert.False(string.IsNullOrEmpty(testName));
        Assert.False(string.IsNullOrEmpty(prodName));
    }
}
